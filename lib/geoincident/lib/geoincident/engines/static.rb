module Geoincident
  require 'geoincident/constants'
  require 'geonicident/helper/types'
  require 'geoincident/helper/trig'

  class StaticDetector
    # this will be the basis for an independent dection engine
    # much like the TrackingDetector
    #
    # at this point this engine cannot be used stand-aloen because
    # it does not support incident generation
    # we rely on the incidents generated by the TrackingDetector
    # then run some calculations and update the incident data

    def run(incident)
      reports = incident.reports
      if reports.length <= 2
        return nil
      end

      combinations = reports.combination(2).to_a
      possible_incidents = get_incident_set(combinations)
      avg_location = calculate_average_location(possible_incidents)
      if avg_location.nil?
        return nil
      end

      std_deviation = calculated_std_deviation(combinations, avg_location)

    end

    def get_incident_set(combinations)
      incidents = []
      combinations.each |c| do
        intersection_point = Trig.points_intersection(
          c[0].latitude.to_rad,
          c[0].longitude.to_rad,
          c[0].heading.to_rad,
          c[1].latitude.to_rad,
          c[1].longitude.to_rad,
          c[1].heading.to_rad
        )

        if intersection_point.nil?
          next
        end

        d1 = Trig.location_distance(
          c[0].latitude.to_rad,
          c[0].longitude.to_rad,
          intersection_point.latitude.to_rad,
          intersection_point.longitude.to_rad
        )

        d2 = Trig.location_distance(
          c[1].latitude.to_rad,
          c[1].longitude.to_rad,
          intersection_point.latitude.to_rad,
          intersection_point.longitude.to_rad
        )

        if d1 <= AVG_DISTANCE and d2 <= AVG_DISTANCE:
          incidents.push(intersection_point)
        end
      end

      incidents
    end

    def calculate_average_location(incidents)
      incidents_count = incidents.length
      if incidents_count == 0
        return nil
      end

      avg_lat = avg_lng = 0
      incidents.each |i| do
        avg_lat += i.latitude
        avg_lng += i.longitude
      end

      avg_lat /= incidents_count
      avg_lng /= incidents_count

      { lat: avg_lat, lng: avg_lng }
    end

    def calculate_std_deviation(combinations, avg_location)
      point = combinations.last
      d1 = (point.latitude - avg_location['lat']) * (point.latitude - avg_location['lat'])
      d2 = (point.longitude - avg_location['lng']) * (point.longitude - avg_location['lng'])
      std_dev = Math.sqrt((d1 + d2) / combinations.length)
    end
  end
end
