module Geoincident
  require 'geoincident/constants'
  require 'geoincident/helper/types'
  require 'geoincident/helper/trig'

  class StaticDetector
    # this will be the basis for an independent dection engine
    # much like the TrackingDetector
    #
    # at this point this engine cannot be used stand-aloen because
    # it does not support incident generation
    # we rely on the incidents generated by the TrackingDetector
    # then run some calculations and update the incident data

    def run(incident)
      reports = incident.reports
      if reports.length <= 2
        return nil
      end

      combinations = reports.combination(2).to_a
      possible_incidents = get_incident_set(combinations)
      avg_location = calculate_average_location(possible_incidents)
      if avg_location.nil?
        return nil
      end

      std_deviation = calculate_std_deviation(possible_incidents, avg_location)

      incident.avg_lat = avg_location[:lat]
      incident.avg_lng = avg_location[:lng]
      incident.std_dev = std_deviation
      incident.save!
    end

    # filter out possible incidents that are generated outside of a specific
    # range
    #
    # returns a list of hashes with :lat and :lng information
    def get_incident_set(combinations)
      incidents = []
      combinations.each do |c|
        intersection_point = Trig.points_intersection(
          c[0].latitude.to_rad,
          c[0].longitude.to_rad,
          c[0].heading.to_rad,
          c[1].latitude.to_rad,
          c[1].longitude.to_rad,
          c[1].heading.to_rad
        )

        if intersection_point.nil?
          next
        end

        d1 = Trig.location_distance(
          c[0].latitude.to_rad,
          c[0].longitude.to_rad,
          intersection_point[:lat],
          intersection_point[:lng]
        )

        d2 = Trig.location_distance(
          c[1].latitude.to_rad,
          c[1].longitude.to_rad,
          intersection_point[:lat],
          intersection_point[:lng]
        )

        if d1 <= AVG_DISTANCE and d2 <= AVG_DISTANCE
          incidents.push(intersection_point)
        end
      end

      incidents
    end

    def calculate_average_location(incidents)
      incidents_count = incidents.length
      if incidents_count == 0
        return nil
      end

      avg_lat = avg_lng = 0
      incidents.each do |incident|
        avg_lat += incident[:lat]
        avg_lng += incident[:lng]
      end

      avg_lat /= incidents_count
      avg_lng /= incidents_count

      { lat: avg_lat, lng: avg_lng }
    end

    def calculate_std_deviation(possible_incidents, avg_location)
      point = possible_incidents.last
      d1 = (point[:lat] - avg_location[:lat]) * (point[:lat] - avg_location[:lat])
      d2 = (point[:lng] - avg_location[:lng]) * (point[:lng] - avg_location[:lng])
      std_dev = Math.sqrt((d1 + d2) / possible_incidents.length)
    end
  end
end
